import base45_swift
import CocoaLumberjackSwift
import Gzip
import SwiftCBOR
#if canImport(UIKit)
import UIKit
#else
import Foundation
#endif

/// Electronic Health Certificate Validation Core
///
/// This struct provides an interface for validating EHN Health certificates generated by https://dev.a-sit.at/certservice
public struct ValidationCore {
    private let PREFIX = "HC1:"
    private let LOGGING_DIR_PATH = "debug-logs"

    private var completionHandler : ((ValidationResult) -> ())?
    #if canImport(UIKit)
    private var scanner : QrCodeScanner?
    #endif
    private let trustlistService : TrustlistService
    private let dateService : DateService

    public init(trustlistService: TrustlistService, dateService: DateService? = nil){
        self.dateService = dateService ?? DefaultDateService()
        self.trustlistService = trustlistService 
        DDLog.add(DDOSLogger.sharedInstance)
   }

    //MARK: - Public API
    
    #if canImport(UIKit)
    /// Instantiate a QR code scanner and validate the scannned EHN health certificate
    public mutating func validateQrCode(_ qrView : UIView, _ completionHandler: @escaping (ValidationResult) -> ()){
        self.completionHandler = completionHandler
        self.scanner = QrCodeScanner()
        scanner?.scan(qrView, self)
    }
    #endif
    
    /// Validate an Base45-encoded EHN health certificate
    public func validate(encodedData: String, _ completionHandler: @escaping (ValidationResult) -> ()) {
        DDLogInfo("Starting validation")
        guard let unprefixedEncodedString = removeScheme(prefix: PREFIX, from: encodedData) else {
            completionHandler(ValidationResult(isValid: false, metaInformation: nil, greenpass: nil, error: .INVALID_SCHEME_PREFIX))
            return
        }
        
        guard let decodedData = decode(unprefixedEncodedString) else {
            completionHandler(ValidationResult(isValid: false, metaInformation: nil, greenpass: nil, error: .BASE_45_DECODING_FAILED))
            return
        }
        DDLogDebug("Base45-decoded data: \(decodedData.asHex())")
        
        guard let decompressedData = decompress(decodedData) else {
            completionHandler(ValidationResult(isValid: false, metaInformation: nil, greenpass: nil, error: .DECOMPRESSION_FAILED))
            return
        }
        DDLogDebug("Decompressed data: \(decompressedData.asHex())")

        guard let cose = cose(from: decompressedData),
              let keyId = cose.keyId else {
            completionHandler(ValidationResult(isValid: false, metaInformation: nil, greenpass: nil, error: .COSE_DESERIALIZATION_FAILED))
            return
        }
        DDLogDebug("KeyID: \(keyId.encode())")
        
        guard let cwt = CWT(from: cose.payload),
              let euHealthCert = cwt.euHealthCert else {
            completionHandler(ValidationResult(isValid: false, metaInformation: nil, greenpass: nil, error: .CBOR_DESERIALIZATION_FAILED))
            return
        }
        
        trustlistService.key(for: keyId, cwt: cwt, keyType: euHealthCert.type) { result in
            switch result {
            case .success(let key):
                guard cose.hasValidSignature(for: key) else {
                    completionHandler(ValidationResult(isValid: false, metaInformation: MetaInfo(from: cwt), greenpass: euHealthCert, error: .SIGNATURE_INVALID))
                    return
                }
                
                guard cwt.isValid(using: dateService) else {
                    completionHandler(ValidationResult(isValid: false, metaInformation: MetaInfo(from: cwt), greenpass: euHealthCert, error: .CWT_EXPIRED))
                    return
                }

                completionHandler(ValidationResult(isValid: true, metaInformation: MetaInfo(from: cwt), greenpass: euHealthCert, error: nil))
            case .failure(let error): completionHandler(ValidationResult(isValid: false, metaInformation: MetaInfo(from: cwt), greenpass: euHealthCert, error: error))
            }
        }
    }

    /// Manually trigger an update for the used trustlist
    public func updateTrustlist(completionHandler: @escaping (ValidationError?)->()) {
        trustlistService.updateTrustlistIfNecessary(completionHandler: completionHandler)
    }
    
    /// Decodes business rules and validates the detached signature
    public func decode(businessRules: Data, signature: Data, trustAnchor: String) throws ->  (SignatureInfo, BusinessRulesContainer) {
        return try DataDecoder().decode(businessRules: businessRules, signature: signature, trustAnchor: trustAnchor, dateService: self.dateService)
    }
    
    /// Decodes value sets and validates the detached signature
    public func decode(valueSet: Data, signature: Data, trustAnchor: String) throws -> (SignatureInfo, ValueSetContainer) {
        return try DataDecoder().decode(valueSets: valueSet, signature: signature, trustAnchor: trustAnchor, dateService: self.dateService)
    }
    
    //MARK: - Helper Functions

    /// Strips a given scheme prefix from the encoded EHN health certificate
    private func removeScheme(prefix: String, from encodedString: String) -> String? {
        guard encodedString.starts(with: prefix) else {
            DDLogError("Encoded data string does not seem to include scheme prefix: \(encodedString.prefix(prefix.count))")
            return nil
        }
        return String(encodedString.dropFirst(prefix.count))
    }
    
    /// Base45-decodes an EHN health certificate
    private func decode(_ encodedData: String) -> Data? {
        return try? encodedData.fromBase45()
    }
    
    /// Decompress the EHN health certificate using ZLib
    private func decompress(_ encodedData: Data) -> Data? {
        return try? encodedData.gunzipped()
    }

    /// Creates COSE structure from EHN health certificate
    private func cose(from data: Data) -> Cose? {
       return Cose(from: data)
    }
}

// MARK: - Health Certificate Debugging
extension ValidationCore {
    
    ///Debug an Base45-encoded EHN health certificate
    public func debug(encodedData: String, anonymizePersonalData: Bool, _ completionHandler: @escaping (ValidationResult) -> ()) {
       guard let loggingDirectory = loggingDirectory()?.path else {
            DDLogInfo("Cannot create logging directory, skipping debug")
            return
        }
        let debugFileManager = DebugLogFileManager(logsDirectory: loggingDirectory)
        debugFileManager.maximumNumberOfLogFiles = 50
        let fileLogger = DDFileLogger(logFileManager: debugFileManager)
        DDLog.add(fileLogger)
        var errors = [ValidationError]()
        
        fileLogger.rollLogFile(withCompletion: {
            DDLogInfo("Scanned QR code payload: \(encodedData)")

            var encodedString = encodedData
            //Prefix
            if let unprefixedEncodedString = removeScheme(prefix: PREFIX, from: encodedData) {
                encodedString = unprefixedEncodedString
            } else {
                DDLogInfo("QR code data has incorrect prefix: \(encodedData.prefix(4)) (should be \(PREFIX))")
                errors.append(.INVALID_SCHEME_PREFIX)
            }
            
            //Try decoding in both cases
            var decodedData = decode(encodedString)
            if nil == decodedData {
                DDLogInfo("QR code data is not decodable from Base45")
                errors.append(.BASE_45_DECODING_FAILED)
            }
            DDLogInfo("QR code payload without prefix:\nBase64: \(decodedData?.base64EncodedString() ?? "<n/a>")\nHex: \(decodedData?.asHex(useSpaces: false) ?? "<n/a>")")

            //Try inflating
            var decompressedData = decompress(decodedData ?? Data())
            if nil == decompressedData {
                DDLogInfo("Payload cannot be inflated, proceeding without")
                decompressedData = decodedData
                errors.append(.DECOMPRESSION_FAILED)
            } else {
                DDLogInfo("Data is decompressable\n")
            }
            DDLogInfo("Base64: \(decompressedData?.base64EncodedString() ?? "<n/a>")\nHex: \(decompressedData?.asHex(useSpaces: false) ?? "<n/a>")")

            let cose = cose(from: decompressedData ?? Data())
            let keyId = cose?.keyId ?? Data()
            if nil == cose {
                errors.append(.COSE_DESERIALIZATION_FAILED)
            }
            DDLogInfo("COSE structure: \(cose?.asJson() ?? "<n/a")")
            
            var cwt = CWT(from: cose?.payload ?? CBOR.null)
            if nil == cwt {
                errors.append(.CBOR_DESERIALIZATION_FAILED)
            }
            
            if anonymizePersonalData {
                cwt?.euHealthCert?.dateOfBirth = "***"
                cwt?.euHealthCert?.person.familyName = "***"
                cwt?.euHealthCert?.person.givenName = "***"
                cwt?.euHealthCert?.person.standardizedGivenName = "***"
                cwt?.euHealthCert?.person.standardizedFamilyName = "***"
            }
            DDLogInfo("CWT structure: \(cwt?.asJson() ?? "<n/a>")")
            let euHealthCert = cwt?.euHealthCert
            
            //TODO retrieve keyId and log signature certificate and trustlist infos
            let certInfo = trustlistService.debugInformation(for: keyId, certType: euHealthCert?.type, cwt: cwt)

            trustlistService.key(for: keyId, keyType: euHealthCert?.type ?? .vaccination) { result in
                switch result {
                case .success(let key):
                    if let cose = cose, !cose.hasValidSignature(for: key) {
                        DDLogInfo("Invalid COSE signature")
                        errors.append(.SIGNATURE_INVALID)
                    }
                    
                    if let cwt = cwt, !cwt.isValid(using: dateService){
                        DDLogInfo("CWT is no longer valid")
                        errors.append(.CWT_EXPIRED)
                    }
                    DDLogInfo("Greenpass seems valid")
                    completionHandler(ValidationResult(isValid: true, metaInformation: MetaInfo(from: cwt, errors: errors), greenpass: euHealthCert, error: nil))
                    return
                case .failure(let error):
                    errors.append(error)
                }
            }

            DDLogInfo("Greenpass seems invalid")
            completionHandler(ValidationResult(isValid: false, metaInformation: MetaInfo(from: cwt, errors: errors), greenpass: euHealthCert, error: errors.first))
        })
    }
    
    public func getLogFiles() -> [URL]? {
        var dirContent = loggingDirContent()
        dirContent?.sort(by: { one, other in
            one.lastPathComponent < other.lastPathComponent
        })
        return dirContent
   }
    
    // Deletes all log files
    public func deleteLogFiles() {
        if let dirContent = loggingDirContent() {
            for file in dirContent {
                try? FileManager.default.removeItem(at: file)
            }
        }
    }
    
    // Returns logging directory
    private func loggingDirectory() -> URL? {
        let supportDirectory = try? FileManager.default.url(for: .applicationSupportDirectory,
                                                                        in: .userDomainMask,
                                                                        appropriateFor: nil,
                                                                        create: true)
        let logDir = supportDirectory?.appendingPathComponent(LOGGING_DIR_PATH)
        if let logDir = logDir,
           !FileManager.default.fileExists(atPath: logDir.path) {
            try? FileManager.default.createDirectory(at: logDir.standardizedFileURL, withIntermediateDirectories: true, attributes: nil)
        }
        return logDir?.standardizedFileURL
    }
    
    // Returns logging directory content
    private func loggingDirContent() -> [URL]? {
        guard let logPath = loggingDirectory() else {
            return nil
        }
        return try? FileManager.default.contentsOfDirectory(at: logPath.standardizedFileURL,
                                                            includingPropertiesForKeys: nil,
                                                            options: .skipsSubdirectoryDescendants)
    }
}

// MARK: - QrCodeReceiver
#if canImport(UIKit)
extension ValidationCore : QrCodeReceiver {
    public func canceled() {
        DDLogDebug("QR code scanning cancelled.")
        completionHandler?(ValidationResult(isValid: false, metaInformation: nil, greenpass: nil, error: .USER_CANCELLED))
    }
    
    /// Process the scanned EHN health certificate
    public func onQrCodeResult(_ result: String?) {
        guard let result = result,
              let completionHandler = self.completionHandler else {
            DDLogError("Cannot read QR code.")
            self.completionHandler?(ValidationResult(isValid: false, metaInformation: nil, greenpass: nil, error: .QR_CODE_ERROR))
            return
        }
        debug(encodedData: result, anonymizePersonalData: true, completionHandler)
//        validate(encodedData: result, completionHandler)
    }
}
#endif


